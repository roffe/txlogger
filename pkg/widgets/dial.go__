package widgets

import (
	"bytes"
	"fmt"
	"image/color"
	"math"

	"fyne.io/fyne/v2"
	"fyne.io/fyne/v2/canvas"
	"fyne.io/fyne/v2/container"
	"fyne.io/fyne/v2/theme"
	"fyne.io/fyne/v2/widget"
	"github.com/roffe/txlogger/pkg/common"
)

type DialConfig struct {
	Title         string
	Min           float64
	Max           float64
	Steps         int
	DisplayString string    // default "%.0f"
	MinSize       fyne.Size // default 260x260
}

type Dial struct {
	widget.BaseWidget
	title         string
	displayString string

	min, max float64
	steps    float64
	factor   float64
	value    float64

	needle *canvas.Line
	pips   []*canvas.Line
	// Add labels slice for speed values
	labels      []*canvas.Text
	face        *canvas.Circle
	center      *canvas.Circle
	cover       *canvas.Rectangle
	displayText *canvas.Text
	titleText   *canvas.Text

	minsize fyne.Size

	container *fyne.Container

	diameter                   float32
	radius                     float32
	middle                     fyne.Position
	needleOffset, needleLength float32
	needleRotConst             float64
	lineRotConst               float64

	buf bytes.Buffer
}

func NewDial(cfg DialConfig) *Dial {
	c := &Dial{
		title:         cfg.Title,
		min:           cfg.Min,
		max:           cfg.Max,
		steps:         30,
		displayString: "%.0f",
		minsize:       fyne.NewSize(100, 100),
	}
	c.ExtendBaseWidget(c)

	if cfg.Steps > 0 {
		c.steps = float64(cfg.Steps)
	}

	if cfg.DisplayString != "" {
		c.displayString = cfg.DisplayString
	}

	if cfg.MinSize.Width > 0 && cfg.MinSize.Height > 0 {
		c.minsize = cfg.MinSize
	}

	c.factor = c.max / c.steps

	c.face = &canvas.Circle{StrokeColor: color.RGBA{0x80, 0x80, 0x80, 255}, StrokeWidth: 3}
	c.cover = &canvas.Rectangle{FillColor: theme.Color(theme.ColorNameBackground)}
	c.center = &canvas.Circle{FillColor: color.RGBA{R: 0x01, G: 0x0B, B: 0x13, A: 0xFF}}
	c.needle = &canvas.Line{StrokeColor: color.RGBA{R: 0xFF, G: 0x67, B: 0, A: 0xFF}, StrokeWidth: 3}

	c.titleText = &canvas.Text{Text: c.title, Color: color.RGBA{R: 0xF0, G: 0xF0, B: 0xF0, A: 0xFF}, TextSize: 25}
	c.titleText.TextStyle.Monospace = true
	c.titleText.Alignment = fyne.TextAlignCenter

	c.displayText = &canvas.Text{Text: "0", Color: color.RGBA{R: 0x2c, G: 0xfc, B: 0x03, A: 0xFF}, TextSize: 52}
	c.displayText.TextStyle.Monospace = true
	c.displayText.Alignment = fyne.TextAlignCenter

	c.container = container.NewWithoutLayout()
	fac := float64(0xA5) / c.steps

	// Create pips and labels
	for i := 0; i <= int(c.steps); i++ {
		// Create pip
		col := color.RGBA{byte(float64(i) * fac), 0x00, 0x00, 0xFF}
		col.G = 0xA5 - col.R
		pip := &canvas.Line{StrokeColor: col, StrokeWidth: 2}
		c.pips = append(c.pips, pip)
		c.container.Add(pip)

		// Create label for even numbered pips
		if i%2 == 0 {
			value := c.min + (float64(i) * ((c.max - c.min) / c.steps))
			label := &canvas.Text{
				Text:      fmt.Sprintf("%.0f", value),
				Color:     col,
				TextSize:  12,
				TextStyle: fyne.TextStyle{Bold: true},
			}
			c.labels = append(c.labels, label)
			c.container.Add(label)
		} else {
			c.labels = append(c.labels, nil)
		}
	}

	c.container.Objects = append(c.container.Objects, c.face, c.cover, c.titleText, c.center, c.needle, c.displayText)

	totalRange := c.max - c.min
	c.needleRotConst = common.Pi15 / (c.steps * (totalRange / c.steps))
	c.lineRotConst = common.Pi15 / c.steps

	return c
}

func (c *Dial) rotateNeedle(hand *canvas.Line, facePosition float64, offset, length float32) {
	normalizedPosition := facePosition - c.min
	if normalizedPosition < 0 {
		normalizedPosition = 0
	}
	c.rotate(hand, c.needleRotConst*normalizedPosition-common.Pi43, offset, length)
}

func (c *Dial) rotateLines(hand *canvas.Line, facePosition float64, offset, length float32) {
	c.rotate(hand, c.lineRotConst*facePosition-common.Pi43, offset, length)
}

func (c *Dial) rotate(hand *canvas.Line, rotation float64, offset, length float32) {
	sinRotation := float32(math.Sin(rotation))
	cosRotation := float32(math.Cos(rotation))
	x2 := length * sinRotation
	y2 := -length * cosRotation
	offX := offset * sinRotation
	offY := -offset * cosRotation
	midxOffX := c.middle.X + offX
	midY := c.middle.Y + offY

	hand.Position1 = fyne.NewPos(midxOffX, midY)
	hand.Position2 = fyne.NewPos(midxOffX+x2, midY+y2)
	hand.Refresh()
}

func (c *Dial) positionLabel(label *canvas.Text, rotation float64, radius float32) {
	// Position label slightly outside the pip line
	labelOffset := radius + 20 // Adjust this value to position labels farther from or closer to the dial

	sinRotation := float32(math.Sin(rotation))
	cosRotation := float32(math.Cos(rotation))

	x := c.middle.X + labelOffset*sinRotation - 10 // Subtract half of approximate text width for centering
	y := c.middle.Y - labelOffset*cosRotation - 5  // Subtract half of approximate text height for centering

	label.Move(fyne.NewPos(x, y))
	label.Refresh()
}

func (c *Dial) SetValue(value float64) {
	if value == c.value {
		return
	}
	c.value = value
	c.rotateNeedle(c.needle, value, c.needleOffset, c.needleLength)
	c.buf.Reset()
	fmt.Fprintf(&c.buf, c.displayString, value)
	c.displayText.Text = c.buf.String()
	c.displayText.Refresh()
}
func (c *Dial) CreateRenderer() fyne.WidgetRenderer {
	return &DialRenderer{
		d: c,
	}
}

type DialRenderer struct {
	d    *Dial
	size fyne.Size
}

// Modified Layout method
func (dr *DialRenderer) Layout(space fyne.Size) {
	if dr.size.Width == space.Width && dr.size.Height == space.Height {
		return
	}
	dr.size = space

	c := dr.d
	c.diameter = fyne.Min(space.Width, space.Height)
	c.radius = c.diameter * common.OneHalf
	c.middle = fyne.NewPos(space.Width*common.OneHalf, space.Height*common.OneHalf)
	c.needleOffset = -c.radius * .15
	c.needleLength = c.radius * 1.14

	stroke := c.diameter * common.OneSixthieth
	midStroke := c.diameter * common.OneEighthieth
	smallStroke := c.diameter * common.OneTwohundredth

	size := fyne.NewSize(c.diameter, c.diameter)
	topleft := fyne.NewPos(c.middle.X-c.radius, c.middle.Y-c.radius)

	// Layout existing elements
	c.titleText.TextSize = c.radius * common.OneFourth
	c.titleText.Move(c.middle.Add(fyne.NewPos(0, c.diameter*common.OneFourth)))
	c.titleText.Refresh()

	center := c.radius * common.OneFourth
	c.center.Move(c.middle.SubtractXY(center*common.OneHalf, center*common.OneHalf))
	c.center.Resize(fyne.NewSize(center, center))

	c.cover.Move(fyne.NewPos(0, c.middle.Y+c.radius*common.OneSeventh*5))
	c.cover.Resize(fyne.NewSize(space.Width, size.Height*common.OneSixth))

	c.displayText.TextSize = c.radius * common.OneHalf
	c.displayText.Move(topleft.AddXY(0, c.diameter*common.OneSixth))
	c.displayText.Resize(size)

	c.needle.StrokeWidth = stroke
	c.rotateNeedle(c.needle, c.value, c.needleOffset, c.needleLength)

	c.face.Move(topleft)
	c.face.Resize(size)

	fourthRadius := c.radius * common.OneFourth
	eightRadius := c.radius * common.OneEight
	radius43 := c.radius * common.OneFourth * 3
	radius87 := c.radius * common.OneEight * 7

	// Layout pips and labels
	for i, p := range c.pips {
		rotation := c.lineRotConst*float64(i) - common.Pi43

		if i%2 == 0 {
			p.StrokeWidth = max(2.0, midStroke)
			c.rotateLines(p, float64(i), radius43, fourthRadius-1)

			// Position label for even-numbered pips
			if label := c.labels[i]; label != nil {
				label.TextSize = c.radius * 0.1 // Adjust text size relative to dial size
				c.positionLabel(label, rotation, c.radius)
			}
		} else {
			p.StrokeWidth = max(2.0, smallStroke)
			c.rotateLines(p, float64(i), radius87, eightRadius-1)
		}
	}
}

// Rest of the renderer methods remain unchanged
func (dr *DialRenderer) MinSize() fyne.Size {
	return dr.d.minsize
}

func (dr *DialRenderer) Refresh() {
}

func (dr *DialRenderer) Destroy() {
}

func (dr *DialRenderer) Objects() []fyne.CanvasObject {
	return []fyne.CanvasObject{dr.d.container}
}
