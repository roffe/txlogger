package vbar

import (
	"image/color"
	"math"
	"strconv"

	"fyne.io/fyne/v2"
	"fyne.io/fyne/v2/canvas"
	"fyne.io/fyne/v2/widget"
	"github.com/roffe/txlogger/pkg/common"
	"github.com/roffe/txlogger/pkg/widgets"
)

// VBar is a lightweight, allocationâ€‘aware vertical bar gauge.
// Key optimizations:
//  - Prebuilt renderer object slice (no per-call allocations in Objects()).
//  - LUT-based color picking (no per-frame branching/float math beyond an index).
//  - Skip work when the pixel height AND color index have not changed.
//  - Cheap int formatting for display (strconv.Itoa on rounded int).
//  - Cached layout factors; avoid repeated MinSize/Size calls.
//  - Reuse canvas primitives; no per-update allocations.

type VBar struct {
	widget.BaseWidget
	face        *canvas.Rectangle
	bar         *canvas.Rectangle
	titleText   *canvas.Text
	displayText *canvas.Text
	bars        []*canvas.Line

	cfg *widgets.GaugeConfig

	value float64

	size         fyne.Size
	layoutValues struct {
		middle        float32
		heightFactor  float32
		diameterEight float32
		twoEight      float32
	}

	// performance caches
	colorLUT       [256]color.RGBA // precomputed fill colors (stroke derived from same idx if needed)
	strokeLUT      [256]color.RGBA
	lastPxHeight   int32
	lastColorIdx   int
	lastIntDisplay int // last integer shown in display
}

func New(cfg *widgets.GaugeConfig) *VBar {
	s := &VBar{cfg: cfg}
	if s.cfg.Steps == 0 {
		s.cfg.Steps = 10
	}
	s.ExtendBaseWidget(s)
	s.render()
	return s
}

func (s *VBar) GetConfig() *widgets.GaugeConfig { return s.cfg }

func (s *VBar) render() {
	s.face = &canvas.Rectangle{
		StrokeColor: color.RGBA{0x80, 0x80, 0x80, 0xFF},
		FillColor:   color.RGBA{0x00, 0x00, 0x00, 0x00},
		StrokeWidth: 3,
	}

	// Precompute LUTs (256 steps) for the full 0..Max range.
	s.buildColorLUT()

	fillColor, strokeColor := s.colorFromIdx(0)
	s.bar = &canvas.Rectangle{StrokeColor: strokeColor, FillColor: fillColor}

	s.titleText = &canvas.Text{Text: s.cfg.Title, Color: color.RGBA{0xF0, 0xF0, 0xF0, 0xFF}, TextSize: 25}
	s.titleText.TextStyle.Monospace = true
	s.titleText.Alignment = fyne.TextAlignCenter

	s.displayText = &canvas.Text{Text: "0", Color: color.RGBA{0xF0, 0xF0, 0xF0, 0xFF}, TextSize: 25}
	s.displayText.TextStyle.Monospace = true
	s.displayText.Alignment = fyne.TextAlignCenter

	// Pre-calculate text positions (approx) using MinSize

	maxSteps := s.cfg.Steps + 1
	s.bars = make([]*canvas.Line, maxSteps)
	for i := maxSteps; i > 0; i-- {
		idx := s.idxForValue(float64(i) / float64(maxSteps) * s.cfg.Max)
		_, stroke := s.colorFromIdx(idx)
		line := &canvas.Line{StrokeColor: stroke, StrokeWidth: 2}
		s.bars[maxSteps-i] = line
	}
}

// buildColorLUT precomputes 256 interpolated entries across the configured scale.
func (s *VBar) buildColorLUT() {
	for i := 0; i < 256; i++ {
		fill, stroke := s.getColorForRatio(float64(i) / 255.0)
		s.colorLUT[i] = fill
		s.strokeLUT[i] = stroke
	}
}

// idxForValue clamps and maps a value to the 0..255 color index.
func (s *VBar) idxForValue(v float64) int {
	if s.cfg.Max <= 0 {
		return 0
	}
	r := v / s.cfg.Max
	if r <= 0 {
		return 0
	}
	if r >= 1 {
		return 255
	}
	return int(r*255.0 + 0.5)
}

func (s *VBar) colorFromIdx(idx int) (fillColor, strokeColor color.RGBA) {
	if idx < 0 {
		idx = 0
	} else if idx > 255 {
		idx = 255
	}
	return s.colorLUT[idx], s.strokeLUT[idx]
}

func (s *VBar) SetValue(value float64) {
	// Fast path: translate to pixel height and color index, bail if unchanged.
	pxHeight := int32(0)
	if s.layoutValues.heightFactor > 0 {
		pxHeight = int32(math.Round(float64(s.layoutValues.heightFactor) * value))
	}
	idx := s.idxForValue(value)
	intDisp := int(math.Round(value))

	changedHeight := pxHeight != s.lastPxHeight
	changedColor := idx != s.lastColorIdx
	changedText := intDisp != s.lastIntDisplay

	if !(changedHeight || changedColor || changedText) {
		return
	}

	s.value = value

	if changedColor {
		fill, _ := s.colorFromIdx(idx)
		s.bar.FillColor = fill
	}
	if changedHeight {
		// Avoid negative sizes
		h := float32(0)
		if pxHeight > 0 {
			h = float32(pxHeight)
		}
		s.bar.Resize(fyne.Size{Width: s.size.Width - s.layoutValues.twoEight, Height: h})
		s.bar.Move(fyne.Position{X: s.layoutValues.diameterEight, Y: s.size.Height - h})
	}
	if changedText {
		// Cheaper than FormatFloat for integer-ish values
		s.displayText.Text = strconv.Itoa(intDisp)
		// Re-center the dynamic text based on its new width
		minDisp := s.displayText.MinSize()
		s.displayText.Move(fyne.Position{X: s.layoutValues.middle - minDisp.Width/2, Y: s.size.Height - minDisp.Height})
		s.displayText.Refresh()
	}

	s.lastPxHeight = pxHeight
	s.lastColorIdx = idx
	s.lastIntDisplay = intDisp
}

func (s *VBar) SetValue2(value float64)             { s.SetValue(value) }
func (s *VBar) Value() float64                      { return s.value }
func (s *VBar) CreateRenderer() fyne.WidgetRenderer { return &VBarRenderer{s: s} }

// getColorForRatio is the original scale logic expressed on 0..1 ratio.
func (s *VBar) getColorForRatio(ratio float64) (fillColor, strokeColor color.RGBA) {
	if s.cfg.ColorScale == widgets.BlueYellowScale {
		if ratio < 0.5 {
			blueRatio := 1 - (ratio * 2)
			r := uint8(0xDD * ratio * 2)
			g := uint8(0x77 + (0x33 * ratio * 2))
			b := uint8(0xBB * blueRatio)
			return color.RGBA{R: r, G: g, B: b, A: 0x80}, color.RGBA{R: r, G: g, B: b, A: 0xFF}
		}
		redRatio := (ratio - 0.5) * 2
		r := uint8(0xDD - (0x11 * redRatio))
		g := uint8(0xAA - (0x77 * redRatio))
		return color.RGBA{R: r, G: g, B: 0x33, A: 0x80}, color.RGBA{R: r, G: g, B: 0x33, A: 0xFF}
	}
	// Traditional scale
	r := uint8(0xA5 * ratio)
	g := uint8(0xA5 * (1 - ratio))
	return color.RGBA{R: r, G: g, B: 0, A: 0x80}, color.RGBA{R: r, G: g, B: 0, A: 0xFF}
}

// VBarRenderer implements a no-allocation Objects() and caches layout math.

type VBarRenderer struct {
	s       *VBar
	objects []fyne.CanvasObject
}

func (r *VBarRenderer) MinSize() fyne.Size { return r.s.cfg.MinSize }
func (r *VBarRenderer) Refresh()           {}
func (r *VBarRenderer) Destroy()           {}

func (r *VBarRenderer) Layout(space fyne.Size) {
	if r.s.size == space {
		return
	}
	r.s.size = space

	// Cache layout calculations
	r.s.layoutValues.middle = space.Width * 0.5
	r.s.layoutValues.diameterEight = space.Width * common.OneEight
	r.s.layoutValues.twoEight = r.s.layoutValues.diameterEight * 2
	if r.s.cfg.Max > 0 {
		r.s.layoutValues.heightFactor = float32(space.Height) / float32(r.s.cfg.Max)
	} else {
		r.s.layoutValues.heightFactor = 0
	}

	stepFactor := float32(space.Height) / float32(r.s.cfg.Steps)

	// Face layout
	r.s.face.Move(fyne.Position{X: 0, Y: -2})
	r.s.face.Resize(space.AddWidthHeight(0, 3))

	// Text layout (use MinSize; avoids calling Size which can be 0 before first draw)
	titleMin := r.s.titleText.MinSize()
	r.s.titleText.Move(fyne.Position{X: r.s.layoutValues.middle - titleMin.Width/2, Y: space.Height + 2})
	minDisp := r.s.displayText.MinSize()
	r.s.displayText.Move(fyne.Position{X: r.s.layoutValues.middle - minDisp.Width/2, Y: space.Height - minDisp.Height})

	// Bar lines layout
	oneThird := space.Width * common.OneThird
	oneSeventh := space.Width * common.OneSeventh
	middle := r.s.layoutValues.middle

	for i, line := range r.s.bars {
		y := float32(i) * stepFactor
		if i%2 == 0 {
			line.Position1 = fyne.Position{X: middle - oneThird, Y: y}
			line.Position2 = fyne.Position{X: middle + oneThird, Y: y}
		} else {
			line.Position1 = fyne.Position{X: middle - oneSeventh, Y: y}
			line.Position2 = fyne.Position{X: middle + oneSeventh, Y: y}
		}
	}

	// Update bar position/size (quantized to pixel height inside SetValue too)
	h := float32(0)
	if r.s.value > 0 && r.s.layoutValues.heightFactor > 0 {
		h = float32(math.Round(float64(r.s.value) * float64(r.s.layoutValues.heightFactor)))
	}
	r.s.bar.Resize(fyne.Size{Width: r.s.size.Width - r.s.layoutValues.twoEight, Height: h})
	r.s.bar.Move(fyne.Position{X: r.s.layoutValues.diameterEight, Y: r.s.size.Height - h})
}

func (r *VBarRenderer) Objects() []fyne.CanvasObject {
	if r.objects != nil {
		return r.objects
	}
	// Build once; reuse to avoid per-call allocations
	objs := make([]fyne.CanvasObject, 0, len(r.s.bars)+4)
	for _, line := range r.s.bars {
		objs = append(objs, line)
	}
	objs = append(objs, r.s.bar, r.s.face, r.s.titleText, r.s.displayText)
	r.objects = objs
	return r.objects
}
